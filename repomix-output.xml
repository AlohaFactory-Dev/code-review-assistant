This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.github/
  workflows/
    code-review-assistant.yml
src/
  services/
    claude.ts
    file-analyzer.ts
    github.ts
    repomix.ts
  templates/
    android.ts
    base.ts
    nextjs.ts
    springboot.ts
    unity.ts
  utils/
    helpers.ts
    log.ts
  index.ts
  types.ts
.gitignore
action.yml
LICENSE
mise.toml
package.json
README.md
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/services/file-analyzer.ts">
import * as core from "@actions/core";
import type {
	FileChange,
	RelatedFiles,
	ReviewContext,
	ReviewOptions,
} from "../types";
import * as github from "@actions/github";
import ignore from "ignore";
import path from "node:path";

export class FileAnalyzerService {
	private options: ReviewOptions;
	private ignoreFilter: ReturnType<typeof ignore>;
	private octokit: ReturnType<typeof github.getOctokit>;
	private context = github.context;

	constructor(token: string, options: ReviewOptions) {
		this.options = options;
		this.octokit = github.getOctokit(token);

		// Set up ignore filter
		this.ignoreFilter = ignore().add(options.excludePatterns);
	}

	shouldAnalyzeFile(filename: string): boolean {
		// Check if file should be ignored
		if (this.ignoreFilter.ignores(filename)) {
			return false;
		}

		// Check if file extension is in the list of extensions to analyze
		const ext = path.extname(filename);
		return this.options.fileExtensions.includes(ext);
	}

	detectProjectType(
		files: FileChange[],
	): "unity" | "springboot" | "android" | "nextjs" {
		// Check for Unity project indicators
		const hasUnityFiles = files.some(
			(file) =>
				file.filename.endsWith(".cs") ||
				file.filename.includes("/Assets/") ||
				file.filename.includes("Assembly-CSharp.csproj"),
		);

		if (hasUnityFiles) {
			return "unity";
		}

		// Check for Spring Boot project indicators
		const hasSpringBootFiles = files.some(
			(file) =>
				file.filename.includes("application.properties") ||
				file.filename.includes("application.yml") ||
				file.filename.includes("build.gradle") ||
				file.filename.includes("pom.xml") ||
				(file.filename.endsWith(".java") &&
					(file.fullContent?.includes("@SpringBootApplication") ||
						file.fullContent?.includes("import org.springframework"))),
		);

		if (hasSpringBootFiles) {
			return "springboot";
		}

		// Check for Android project indicators
		const hasAndroidFiles = files.some(
			(file) =>
				file.filename.includes("AndroidManifest.xml") ||
				file.filename.includes("build.gradle") ||
				file.filename.endsWith(".kt") ||
				(file.filename.endsWith(".java") &&
					(file.fullContent?.includes("import android.") ||
						file.fullContent?.includes("extends Activity"))),
		);

		if (hasAndroidFiles) {
			return "android";
		}

		// Check for Next.js project indicators
		const hasNextJsFiles = files.some(
			(file) =>
				file.filename.includes("next.config.js") ||
				file.filename.includes("pages/") ||
				file.filename.includes("app/") ||
				(file.filename.endsWith(".js") &&
					file.fullContent?.includes("import { useRouter }")) ||
				(file.filename.endsWith(".tsx") &&
					file.fullContent?.includes("import { GetServerSideProps }")),
		);

		if (hasNextJsFiles) {
			return "nextjs";
		}

		// Default to Next.js if we can't determine the project type (since it's the most generic)
		return "nextjs";
	}

	async findRelatedFiles(context: ReviewContext): Promise<RelatedFiles> {
		if (!this.options.findRelatedFiles) {
			return {};
		}

		core.info("Finding related files...");
		const relatedFiles: RelatedFiles = {};
		const { owner, repo } = this.context.repo;

		// For each changed file, search for related files
		for (const file of context.files) {
			const filename = path.basename(file.filename);
			const fileNameWithoutExt = path.basename(
				filename,
				path.extname(filename),
			);

			// Skip files that were removed
			if (file.status === "removed") {
				continue;
			}

			try {
				// Simple approach: search for files containing the name of the changed file
				const searchResult = await this.octokit.rest.search.code({
					q: `repo:${owner}/${repo} ${fileNameWithoutExt} in:file`,
					per_page: 30,
				});

				const related = searchResult.data.items
					.filter(
						(item) =>
							// Exclude the file itself
							item.path !== file.filename &&
							// Make sure the file extension is in our list
							this.shouldAnalyzeFile(item.path) &&
							// Make sure the file is not in the ignore list
							!this.ignoreFilter.ignores(item.path),
					)
					.map((item) => item.path);

				if (related.length > 0) {
					relatedFiles[file.filename] = related;
				}
			} catch (error) {
				if (error instanceof Error) {
					core.warning(
						`Error finding related files for ${file.filename}: ${error.message}`,
					);
				}
			}
		}

		core.info(
			`Found related files for ${Object.keys(relatedFiles).length} changed files`,
		);
		return relatedFiles;
	}
}
</file>

<file path="src/templates/android.ts">
import type { PromptTemplate, ReviewContext } from "../types";
import { BasePromptTemplate } from "./base";

export class AndroidPromptTemplate implements PromptTemplate {
	generatePrompt(context: ReviewContext): string {
		// Start with the base prompt
		const basePrompt = new BasePromptTemplate().generatePrompt(context);

		// Add Android-specific guidance
		return `${basePrompt}

Android 프로젝트 관련 추가 지침:

1. 아키텍처 및 구조:
   - MVVM, MVP, MVC 등의 아키텍처 패턴이 일관되게 적용되었는지 확인하세요.
   - 비즈니스 로직이 UI 코드에서 분리되었는지 확인하세요.
   - Clean Architecture 원칙이 준수되고 있는지 평가하세요.

2. 생명주기 관리:
   - Activity/Fragment 생명주기 메서드의 적절한 사용을 확인하세요.
   - 메모리 누수 위험이 있는 코드를 식별하세요(예: 익명 내부 클래스, 비정상적 참조 유지).
   - ViewModel과 LiveData/Flow의 올바른 사용을 확인하세요.

3. UI/UX 고려사항:
   - UI 스레드 차단 코드를 식별하고 백그라운드 처리를 권장하세요.
   - RecyclerView/ListView의 효율적인 구현을 확인하세요.
   - 화면 방향 변경 및 다양한 화면 크기 대응을 확인하세요.

4. 성능 최적화:
   - 불필요한 객체 생성을 식별하세요.
   - ANR 가능성이 있는 코드를 식별하세요.
   - 배터리 소모를 줄이기 위한 최적화 방안을 제안하세요.

5. 현대적 안드로이드 개발:
   - Kotlin 언어 기능(확장 함수, 코루틴, flow 등)의 적절한 활용을 권장하세요.
   - Jetpack 컴포넌트의 활용을 장려하세요.
   - Compose UI 전환 가능성을 검토하세요.

6. 네트워크 및 데이터:
   - Retrofit과 같은 현대적 라이브러리 사용을 권장하세요.
   - Room 데이터베이스의 적절한 활용을 확인하세요.
   - 네트워크 에러 처리 및 오프라인 모드 지원을 확인하세요.

이러한 추가 지침을 고려하여 Android 프로젝트에 특화된 코드 리뷰를 제공해주세요.
`;
	}
}
</file>

<file path="src/templates/base.ts">
import type { ProjectType, PromptTemplate, ReviewContext } from "../types";
import { UnityPromptTemplate } from "./unity";
import { SpringBootPromptTemplate } from "./springboot";
import { AndroidPromptTemplate } from "./android";
import { NextJsPromptTemplate } from "./nextjs";

export function getPromptTemplate(type: ProjectType): PromptTemplate {
	switch (type) {
		case "unity":
			return new UnityPromptTemplate();
		case "springboot":
			return new SpringBootPromptTemplate();
		case "android":
			return new AndroidPromptTemplate();
		case "nextjs":
			return new NextJsPromptTemplate();
		default:
			return new BasePromptTemplate();
	}
}

export class BasePromptTemplate implements PromptTemplate {
	generatePrompt(context: ReviewContext): string {
		const { files, relatedFiles } = context;

		let prompt = `
경험 많은 시니어 개발자로서, 다음 변경사항들에 대해 전체적이고 간결한 코드 리뷰를 수행해주세요.

리뷰 지침:
1. 모든 변경사항을 종합적으로 검토하고, 가장 중요한 문제점이나 개선사항에만 집중하세요.
2. 파일별로 개별 리뷰를 하지 말고, 전체 변경사항에 대한 통합된 리뷰를 제공하세요.
3. 각 주요 이슈에 대해 간단한 설명과 구체적인 개선 제안을 제시하세요.
4. 개선 제안에는 실제 코드 예시를 포함하세요. 단, 코드 예시는 제공한 코드와 연관된 코드여야 합니다.
5. 사소한 스타일 문제나 개인적 선호도는 무시하세요.
6. 심각한 버그, 성능 문제, 또는 보안 취약점이 있는 경우에만 언급하세요.
7. 전체 리뷰는 간결하게 유지하세요.
8. 변경된 부분만 집중하여 리뷰하고, 이미 개선된 코드를 다시 지적하지 마세요.
9. 기존에 이미 개선된 사항(예: 중복 코드 제거를 위한 함수 생성)을 인식하고 이를 긍정적으로 언급하세요.
10. 변경된 파일과 관련된 다른 파일들에 미칠 수 있는 영향을 분석하세요.

리뷰 형식:
- 개선된 사항: [이미 개선된 부분에 대한 긍정적 언급]
- 주요 이슈 (있는 경우에만):
  1. [문제 설명]
     - 제안: [개선 방안 설명]
     \`\`\`
     // 수정된 코드 예시
     \`\`\`
  2. ...
- 관련 파일에 대한 영향 분석:
  [변경된 파일과 관련된 다른 파일들에 미칠 수 있는 잠재적 영향 설명]
- 전반적인 의견: [1-2문장으로 요약]

변경된 파일들:
`;

		// Add changed files to the prompt
		for (const file of files) {
			prompt += `- ${file.filename} (${file.status})\n`;
		}

		// Add file contents to the prompt
		prompt += "\n변경 내용:\n";
		for (const file of files) {
			if (file.status === "removed") {
				prompt += `파일: ${file.filename}\n상태: 삭제됨\n\n`;
			} else {
				prompt += `파일: ${file.filename}\n`;

				if (file.fullContent) {
					prompt += `전체 내용:\n${file.fullContent}\n\n`;
				}

				if (file.patch) {
					prompt += `변경된 부분:\n${file.patch}\n\n`;
				}
			}
		}

		// Add related files information
		if (Object.keys(relatedFiles).length > 0) {
			prompt += "\n관련된 파일들:\n";

			for (const [changedFile, related] of Object.entries(relatedFiles)) {
				prompt += `- ${changedFile}에 영향을 받을 수 있는 파일들:\n`;

				for (const relatedFile of related) {
					prompt += `  - ${relatedFile}\n`;
				}
			}
		}

		return prompt;
	}
}
</file>

<file path="src/templates/nextjs.ts">
import type { PromptTemplate, ReviewContext } from "../types";
import { BasePromptTemplate } from "./base";

export class NextJsPromptTemplate implements PromptTemplate {
	generatePrompt(context: ReviewContext): string {
		// Start with the base prompt
		const basePrompt = new BasePromptTemplate().generatePrompt(context);

		// Add Next.js-specific guidance
		return `${basePrompt}

Next.js 프로젝트 관련 추가 지침:

1. 렌더링 최적화:
   - 서버 컴포넌트와 클라이언트 컴포넌트의 적절한 사용을 확인하세요.
   - 불필요한 클라이언트 사이드 렌더링을 식별하고 서버 컴포넌트로의 전환을 권장하세요.
   - 정적 생성(SSG)과 서버 사이드 렌더링(SSR)의 적절한 활용을 확인하세요.

2. 라우팅 및 데이터 페칭:
   - App Router와 Pages Router의 일관된 사용을 확인하세요.
   - Next.js의 데이터 페칭 메서드(getServerSideProps, getStaticProps, fetch 등)의 적절한 사용을 평가하세요.
   - 불필요한 리렌더링을 유발하는 코드를 식별하세요.

3. 상태 관리:
   - 전역 상태 관리의 필요성과 그 구현을 평가하세요(Context API, Redux, Zustand 등).
   - 컴포넌트 간 상태 공유가 효율적으로 이루어지는지 확인하세요.
   - 서버 상태와 클라이언트 상태의 적절한 분리를 확인하세요.

4. 성능 고려사항:
   - 불필요한 번들 크기 증가 요소를 식별하세요.
   - 이미지 최적화(next/image)의 사용을 확인하세요.
   - 컴포넌트 메모이제이션(React.memo, useMemo, useCallback)의 적절한
   - 사용을 확인하세요.

5. 타입스크립트 활용:
   - 엄격한 타입 검사를 위한 설정을 권장하세요.
   - any 타입의 사용을 지양하고 구체적인 타입 정의를 권장하세요.
   - 재사용 가능한 타입 정의와 인터페이스의 활용을 확인하세요.

6. 접근성 및 SEO:
   - 시맨틱 HTML 요소의 적절한 사용을 확인하세요.
   - alt 속성, ARIA 속성 등 접근성 관련 속성의 사용을 확인하세요.
   - SEO 최적화를 위한 메타 태그의 사용을 확인하세요.

이러한 추가 지침을 고려하여 Next.js 프로젝트에 특화된 코드 리뷰를 제공해주세요.
`;
	}
}
</file>

<file path="src/templates/springboot.ts">
import type { PromptTemplate, ReviewContext } from "../types";
import { BasePromptTemplate } from "./base";

export class SpringBootPromptTemplate implements PromptTemplate {
	generatePrompt(context: ReviewContext): string {
		// Start with the base prompt
		const basePrompt = new BasePromptTemplate().generatePrompt(context);

		// Add Spring Boot-specific guidance
		return `${basePrompt}

Spring Boot 프로젝트 관련 추가 지침:

1. 아키텍처 및 구조:
   - 계층 구조(Controller, Facade, Service, Repository)가 적절히 구분되었는지 확인하세요.
   - DTO, Entity, VO 객체의 적절한 사용을 평가하세요.
   - 관심사 분리가 잘 되어 있는지 확인하세요.

2. Spring 이디엄 및 패턴:
   - @Transactional 어노테이션의 적절한 사용을 확인하세요.
   - DI(의존성 주입)이 생성자 주입 방식으로 구현되었는지 권장하세요.
   - @Autowired 필드 주입보다 생성자 주입을 권장하세요.

3. 성능 고려사항:
   - N+1 쿼리 문제가 발생할 수 있는 코드를 확인하세요.
   - 불필요한 데이터베이스 호출이 있는지 확인하세요.
   - 캐싱 적용이 필요한 부분을 식별하세요.

4. 예외 처리:
   - 전역 예외 처리기의 사용을 확인하세요.
   - 비즈니스 로직에 맞는 커스텀 예외를 사용하는지 확인하세요.
   - try-catch 블록이 적절히 사용되었는지 확인하세요.

5. 보안:
   - SQL 인젝션 방지를 위해 JPA 또는 명명된 파라미터를 사용하는지 확인하세요.
   - 인증/인가 코드의 적절한 구현을 확인하세요.
   - 민감한 정보가 로그에 노출되지 않는지 확인하세요.

이러한 추가 지침을 고려하여 Spring Boot 프로젝트에 특화된 코드 리뷰를 제공해주세요.
`;
	}
}
</file>

<file path="src/templates/unity.ts">
import type { PromptTemplate, ReviewContext } from "../types";
import { BasePromptTemplate } from "./base";

export class UnityPromptTemplate implements PromptTemplate {
	generatePrompt(context: ReviewContext): string {
		// Start with the base prompt
		const basePrompt = new BasePromptTemplate().generatePrompt(context);

		// Add Unity-specific guidance
		return `${basePrompt}

Unity 프로젝트 관련 추가 지침:

1. 성능 고려사항:
   - Update() 메서드에서 무거운 연산이 있는지 확인하세요.
   - GetComponent() 호출이 반복문 내에 있는지 확인하고, 캐싱을 제안하세요.
   - 오브젝트 풀링이 적용 가능한 상황인지 평가하세요.
   - 불필요한 Instantiate/Destroy 호출을 찾아 최적화 방안을 제안하세요.

2. 코드 구조:
   - MonoBehaviour를 적절히 활용하고 있는지 확인하세요.
   - 싱글톤 패턴의 올바른 구현을 확인하고, 의존성 주입을 고려하세요.
   - 컴포넌트 간 통신 방식이 효율적인지 평가하세요.

3. 안전성:
   - null 참조 가능성을 확인하고, [SerializeField] 또는 RequireComponent 속성 사용을 권장하세요.
   - 코루틴 관리가 적절한지 확인하세요.
   - 이벤트 구독/해제가 짝을 이루는지 확인하세요.

4. Unity 특화 패턴:
   - ScriptableObject 활용 기회를 찾으세요.
   - Unity의 새로운 Input System을 사용할 것을 권장하세요.
   - GameObject.Find() 및 싱글톤 대신 의존성 주입 패턴을 권장하세요.

이러한 추가 지침을 고려하여 Unity 프로젝트에 특화된 코드 리뷰를 제공해주세요.
`;
	}
}
</file>

<file path="src/utils/helpers.ts">
import path from "node:path";

/**
 * Groups an array into chunks of specified size
 */
export function chunkArray<T>(array: T[], chunkSize: number): T[][] {
	const chunks: T[][] = [];
	for (let i = 0; i < array.length; i += chunkSize) {
		chunks.push(array.slice(i, i + chunkSize));
	}
	return chunks;
}

/**
 * Extracts filename without extension
 */
export function getFilenameWithoutExt(filePath: string): string {
	const basename = path.basename(filePath);
	return basename.substring(0, basename.lastIndexOf("."));
}

/**
 * Truncates a string to a maximum length with an ellipsis
 */
export function truncate(str: string, maxLength: number): string {
	if (str.length <= maxLength) {
		return str;
	}
	return `${str.substring(0, maxLength - 3)}...`;
}

/**
 * Estimates token count in a string (very rough approximation)
 */
export function estimateTokenCount(text: string): number {
	// Rough approximation: 1 token ~= 4 characters for English text
	return Math.ceil(text.length / 4);
}

/**
 * Delays execution for specified milliseconds
 */
export function delay(ms: number): Promise<void> {
	return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * Retries a function with exponential backoff
 */
export async function retryWithBackoff<T>(
	fn: () => Promise<T>,
	maxRetries = 3,
	initialDelay = 1000,
): Promise<T> {
	let retries = 0;
	let delay = initialDelay;

	while (true) {
		try {
			return await fn();
		} catch (error) {
			retries++;
			if (retries >= maxRetries) {
				throw error;
			}
			await new Promise((resolve) => setTimeout(resolve, delay));
			delay *= 2; // Exponential backoff
		}
	}
}
</file>

<file path="src/utils/log.ts">
import * as core from '@actions/core';

export enum LogLevel {
  DEBUG = 'debug',
  INFO = 'info',
  WARNING = 'warning',
  ERROR = 'error',
}

export class Logger {
  static debug(message: string): void {
    core.debug(message);
  }

  static info(message: string): void {
    core.info(message);
  }

  static warning(message: string): void {
    core.warning(message);
  }

  static error(message: string): void {
    core.error(message);
  }

  static group(name: string): void {
    core.startGroup(name);
  }

  static endGroup(): void {
    core.endGroup();
  }
}
</file>

<file path=".gitignore">
# Dependency directory
node_modules

# Rest pulled from https://github.com/github/gitignore/blob/master/Node.gitignore
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
jspm_packages/

# TypeScript v1 declaration files
typings/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
.env.test

# parcel-bundler cache (https://parceljs.org/)
.cache

# next.js build output
.next

# nuxt.js build output
.nuxt

# vuepress build output
.vuepress/dist

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# OS metadata
.DS_Store
Thumbs.db

# Ignore built ts files
__tests__/runner/*

# IDE files
.idea
*.code-workspace
</file>

<file path="LICENSE">
Copyright 2025 Aloha Factory

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the “Software”), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</file>

<file path="mise.toml">
[tools]
biome = "latest"
node = "latest"
pnpm = "latest"
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true
  },
  "exclude": ["node_modules", "**/*.test.ts", "dist"]
}
</file>

<file path="src/services/repomix.ts">
import * as core from "@actions/core";
import * as path from "node:path";
import * as fs from "node:fs";
import { exec } from "node:child_process";
import { promisify } from "node:util";
import type { ReviewContext } from "../types";

const execAsync = promisify(exec);

export class RepomixService {
	/**
	 * Packs the repository using Repomix and returns the content
	 * to be used by Claude for a more comprehensive code review
	 */
	async packRepository(context: ReviewContext): Promise<string> {
		try {
			core.info("Packing repository with Repomix...");

			// Create a temp directory for the output
			const tempDir = path.join(process.cwd(), ".repomix-temp");
			if (!fs.existsSync(tempDir)) {
				fs.mkdirSync(tempDir);
			}

			// Output file path
			const outputFilePath = path.join(tempDir, "repo-pack.md");

			// Create a basic config file for Repomix
			const configFilePath = path.join(tempDir, "repomix.config.json");

			// Create instruction file
			const instructionFilePath = this.createInstructionFile(context);

			const config = {
				output: {
					path: outputFilePath,
					includeRepositoryStructure: true,
					removeComments: false,
					instructionFilePath: instructionFilePath,
				},
				ignore: {
					useGitignore: true,
					useDefaultPatterns: true,
					customPatterns: context.files
						.filter((f) => f.status === "removed")
						.map((f) => f.filename),
				},
				security: {
					enableSecurityCheck: true,
				},
			};

			fs.writeFileSync(configFilePath, JSON.stringify(config, null, 2));

			// Run Repomix CLI command
			core.info("Running Repomix...");
			const { stdout, stderr } = await execAsync(
				`npx repomix --config ${configFilePath}`,
			);

			if (stderr) {
				core.warning(`Repomix warnings: ${stderr}`);
			}

			core.info(`Repomix output: ${stdout}`);

			// Read the packed file
			if (!fs.existsSync(outputFilePath)) {
				throw new Error("Repomix did not generate the output file");
			}

			const packedContent = fs.readFileSync(outputFilePath, "utf8");

			// Clean up
			try {
				fs.unlinkSync(outputFilePath);
				fs.unlinkSync(configFilePath);
				fs.rmdirSync(tempDir);
			} catch (cleanupError) {
				core.warning(
					`Failed to clean up temporary files: ${cleanupError instanceof Error ? cleanupError.message : String(cleanupError)}`,
				);
			}

			core.info(
				`Repository packed successfully - ${(packedContent.length / 1024).toFixed(2)} KB`,
			);
			return packedContent;
		} catch (error) {
			core.error(
				`Failed to pack repository: ${error instanceof Error ? error.message : String(error)}`,
			);
			return "Failed to pack repository with Repomix";
		}
	}

	/**
	 * Creates a custom instruction file for Repomix
	 * based on the PR context and the review requirements
	 */
	createInstructionFile(context: ReviewContext): string {
		const tempDir = path.join(process.cwd(), ".repomix-temp");
		if (!fs.existsSync(tempDir)) {
			fs.mkdirSync(tempDir);
		}

		const instructionPath = path.join(tempDir, "review-instructions.md");

		// Create detailed instructions for Claude
		const instructions = `# Code Review Instructions

## Pull Request Information
- **PR Title:** ${context.pullRequestTitle}
- **PR Number:** ${context.pullRequestNumber}
- **Repository:** ${context.repositoryOwner}/${context.repositoryName}
- **Branch:** ${context.branch}
- **Base:** ${context.baseRef}

## Changed Files
Please focus your review on these files that were changed in the PR:
${context.files.map((file) => `- \`${file.filename}\` (${file.status})`).join("\n")}

## Review Guidelines
1. Identify bugs, security issues, and potential problems
2. Suggest code improvements for readability and maintainability
3. Check for performance issues
4. Ensure proper error handling
5. Verify code follows project patterns and conventions
6. Provide specific, actionable feedback with code examples

## Repository Context
The code above contains the full repository context to help you understand the codebase better.
`;

		fs.writeFileSync(instructionPath, instructions);
		return instructionPath;
	}
}
</file>

<file path="action.yml">
name: 'Code Review Assistant'
description: 'Automated code reviews using Claude AI with support for various project types'
author: 'Aloha Factory'

inputs:
  github-token:
    description: 'GitHub token for API authentication'
    required: true
  claude-api-key:
    description: 'Claude API key'
    required: true
  project-type:
    description: 'Project type (unity, springboot, android, nextjs, or auto)'
    required: false
    default: 'auto'
  file-extensions:
    description: 'Comma-separated list of file extensions to analyze'
    required: false
    default: '.ts,.js,.tsx,.jsx,.cs,.java,.kt,.xml,.json,.yaml,.yml'
  exclude-patterns:
    description: 'Comma-separated list of glob patterns to exclude'
    required: false
    default: 'node_modules/**,dist/**,build/**,*.min.js,*.test.*'
  find-related-files:
    description: 'Whether to find and analyze related files'
    required: false
    default: 'true'
  max-files:
    description: 'Maximum number of files to analyze in a single PR'
    required: false
    default: '10'
  model:
    description: 'Claude model to use'
    required: false
    default: 'claude-3-5-haiku-20241022'
  use-repomix:
    description: 'Whether to use Repomix to pack repository for comprehensive review'
    required: false
    default: 'true'

runs:
  using: 'node20'
  main: 'dist/index.js'

branding:
  icon: 'code'
  color: 'purple'
</file>

<file path="README.md">
# Code Review Assistant

![Code Review](https://img.shields.io/badge/AI-Code%20Review-purple)
![TypeScript](https://img.shields.io/badge/Language-TypeScript-blue)
![GitHub Actions](https://img.shields.io/badge/CI-GitHub%20Actions-2088FF)

이 GitHub Action은 [Anthropic의 Claude API](https://www.anthropic.com/claude)를 활용하여 풀 리퀘스트에 대한 자동화된 코드 리뷰를 제공합니다. 다양한 프로젝트 유형(Unity, Spring Boot, Android, Next.js 등)에 특화된 리뷰를 제공하며, 코드베이스의 특성에 맞는 맞춤형 피드백을 생성합니다. [Repomix](https://github.com/yamadashy/repomix)를 활용하여 전체 저장소 컨텍스트에 대한 심층적인 이해를 기반으로 더욱 정확하고 포괄적인 코드 리뷰를 제공합니다.

## 주요 기능

- **프로젝트 유형 자동 감지**: 파일 패턴과 내용을 분석하여 프로젝트 유형을 자동으로 식별합니다.
- **특화된 코드 리뷰**: 각 프로젝트 유형에 맞는 특화된 리뷰 가이드라인을 적용합니다.
- **관련 파일 분석**: 변경된 파일과 연관된 다른 파일들을 찾아 포괄적인 리뷰를 제공합니다.
- **전체 저장소 컨텍스트**: Repomix를 사용하여 전체 저장소를 패키징하고 AI에게 제공하여 코드베이스에 대한 심층적인 이해를 바탕으로 더 나은 리뷰를 제공합니다.
- **구체적인 개선 제안**: 문제점을 식별하고 코드 예시와 함께 구체적인 개선 방안을 제시합니다.
- **다양한 설정 옵션**: 분석할 파일 확장자, 제외 패턴, 모델 선택 등 다양한 설정이 가능합니다.

## 사용 방법

### 1. 시크릿 설정

GitHub 저장소의 "Settings" > "Secrets and variables" > "Actions"에서 다음 시크릿을 추가합니다:

- `CLAUDE_API_KEY`: Anthropic API 키

### 2. 워크플로우 추가

`.github/workflows/code-review-assistant.yml` 파일을 생성하고 다음 내용을 추가합니다:

```yaml
name: Code Review Assistant

on:
  pull_request:
    types: [opened, synchronize]

permissions:
  contents: read
  pull-requests: write

jobs:
  code-review:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Run Code Review Assistant
        uses: AlohaFactory-Dev/code-review-assistant@v1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          claude-api-key: ${{ secrets.CLAUDE_API_KEY }}
          project-type: 'auto'
          use-repomix: 'true'
```

### 3. 옵션 설정

다음 옵션을 설정하여 코드 리뷰를 맞춤화할 수 있습니다:

- `project-type`: 프로젝트 유형 ('unity', 'springboot', 'android', 'nextjs', 'auto')
- `file-extensions`: 분석할 파일 확장자
- `exclude-patterns`: 제외할 파일 패턴
- `find-related-files`: 관련 파일 분석 여부
- `max-files`: 한 번에 분석할 최대 파일 수
- `model`: 사용할 Claude 모델
- `use-repomix`: Repomix를 사용하여 전체 저장소 컨텍스트를 AI에게 제공할지 여부 (기본값: true)

## 지원하는 프로젝트 유형

- **Unity**: Unity 게임 개발 프로젝트
- **Spring Boot**: Java 기반 백엔드 프로젝트
- **Android**: 안드로이드 앱 개발 프로젝트
- **Next.js**: React 기반 프론트엔드 프로젝트

## Repomix 통합

이 액션은 [Repomix](https://github.com/yamadashy/repomix)를 통합하여 다음과 같은 이점을 제공합니다:

- **전체 코드베이스 컨텍스트**: Claude에게 전체 저장소 구조와 코드를 제공하여 코드베이스에 대한 더 깊은 이해를 기반으로 리뷰를 생성합니다.
- **더 나은 코드 패턴 인식**: 저장소 전체의 패턴과 규칙을 파악하여 일관성 있는 리뷰 제안을 제공합니다.
- **관련 코드 참조**: 변경 사항과 관련된 다른 파일의 코드를 참조하여 더 정확한 피드백을 제공합니다.

Repomix 사용을 비활성화하려면 `use-repomix: 'false'`로 설정하세요.

## 비용 최적화 팁

Claude API 사용에는 비용이 발생하므로, 다음 최적화를 고려하세요:

1. 특정 브랜치나 파일 유형에 대해서만 코드 리뷰를 실행
2. `max-files` 값을 조절하여 분석할 파일 수 제한
3. `find-related-files` 옵션을 상황에 따라 비활성화
4. 필요에 따라 더 경제적인 모델 사용
5. 대규모 저장소의 경우 `use-repomix: 'false'`로 설정하여 컨텍스트 크기 감소

## 라이센스

MIT

## 기여하기

이슈 및 풀 리퀘스트를 환영합니다. 새로운 프로젝트 유형 지원이나 기능 개선에 기여해 주세요.
</file>

<file path="src/services/github.ts">
import * as github from "@actions/github";
import * as core from "@actions/core";
import type { FileChange, ReviewContext, StructuredReview } from "../types";
import type { FileAnalyzerService } from "./file-analyzer";

export class GitHubService {
	private octokit: ReturnType<typeof github.getOctokit>;
	private fileAnalyzer: FileAnalyzerService;
	private context = github.context;

	constructor(token: string, fileAnalyzer: FileAnalyzerService) {
		this.octokit = github.getOctokit(token);
		this.fileAnalyzer = fileAnalyzer;
	}

	async getPullRequestDetails(): Promise<{
		number: number;
		title: string;
		body: string | null;
		head: { ref: string; sha: string };
		base: { ref: string };
	}> {
		const { pull_request } = this.context.payload;

		if (!pull_request) {
			throw new Error("This action can only be run on pull request events");
		}

		return {
			number: pull_request.number,
			title: pull_request.title,
			body: pull_request.body ?? null,
			head: {
				ref: pull_request.head.ref,
				sha: pull_request.head.sha,
			},
			base: {
				ref: pull_request.base.ref,
			},
		};
	}

	async getChangedFiles(prNumber: number): Promise<FileChange[]> {
		const { owner, repo } = this.context.repo;
		core.info(`Fetching changed files for PR #${prNumber}...`);

		const changedFiles: FileChange[] = [];
		let page = 1;
		let hasMorePages = true;

		while (hasMorePages) {
			const response = await this.octokit.rest.pulls.listFiles({
				owner,
				repo,
				pull_number: prNumber,
				per_page: 100,
				page,
			});

			if (response.data.length === 0) {
				hasMorePages = false;
				break;
			}

			for (const file of response.data) {
				if (!this.fileAnalyzer.shouldAnalyzeFile(file.filename)) {
					continue;
				}

				const fileChange: FileChange = {
					filename: file.filename,
					status: file.status as "added" | "modified" | "removed" | "renamed",
					patch: file.patch,
				};

				changedFiles.push(fileChange);
			}

			page++;
		}

		core.info(`Found ${changedFiles.length} relevant changed files`);
		return changedFiles;
	}

	async getFileContent(filepath: string, ref: string): Promise<string> {
		const { owner, repo } = this.context.repo;

		try {
			const response = await this.octokit.rest.repos.getContent({
				owner,
				repo,
				path: filepath,
				ref,
			});

			// @ts-ignore - The type definitions don't account for the content property correctly
			if (response.data.content && response.data.encoding === "base64") {
				// @ts-ignore
				return Buffer.from(response.data.content, "base64").toString("utf-8");
			}

			throw new Error(`Unexpected response format for file: ${filepath}`);
		} catch (error) {
			if (error instanceof Error) {
				core.warning(
					`Error fetching file content for ${filepath}: ${error.message}`,
				);
			}
			return "";
		}
	}

	async createReviewComment(prNumber: number, review: string): Promise<void> {
		const { owner, repo } = this.context.repo;

		try {
			await this.octokit.rest.issues.createComment({
				owner,
				repo,
				issue_number: prNumber,
				body: `# Claude AI 코드 리뷰\n\n${review}`,
			});

			core.info("Successfully posted code review comment");
		} catch (error) {
			if (error instanceof Error) {
				core.error(`Error posting review comment: ${error.message}`);
			} else {
				core.error("Unknown error posting review comment");
			}
		}
	}

	async createReviewWithComments(
		prNumber: number,
		review: StructuredReview,
	): Promise<void> {
		const { owner, repo } = this.context.repo;
		const { summary, comments } = review;

		try {
			// Check if the summary is from an error in Claude service
			const isErrorSummary =
				summary.includes("코드 리뷰 응답 파싱에 실패했습니다") ||
				summary.includes("Claude 코드 리뷰 생성 중 오류가 발생했습니다") ||
				summary.includes("알 수 없는 오류로 코드 리뷰를 생성할 수 없습니다");

			// Only post regular comment if it's not an error summary
			if (!isErrorSummary) {
				// First post the overall review as a regular comment (like before)
				await this.octokit.rest.issues.createComment({
					owner,
					repo,
					issue_number: prNumber,
					body: `# AI 코드 리뷰\n\n${summary}`,
				});

				core.info("Successfully posted overall review comment");
			} else {
				core.info(
					"Skipping posting summary comment as it contains an error message",
				);
				return; // Exit early if there's an error summary
			}

			// Only continue with line comments if there are actual comments
			if (comments.length === 0) {
				core.info(
					"No line-specific comments to post, skipping review creation",
				);
				return;
			}

			// Get the latest commit SHA for the pull request
			const prResponse = await this.octokit.rest.pulls.get({
				owner,
				repo,
				pull_number: prNumber,
			});

			const headSha = prResponse.data.head.sha;

			// Format review comments in the GitHub expected format
			// Filter out invalid comments and ensure required fields are present
			const reviewComments = comments
				.filter((comment) => comment.body && comment.line > 0 && comment.path)
				.map((comment) => ({
					path: comment.path,
					line: comment.line, // Use line for the diff line number
					body: comment.body || "No comment provided", // Ensure body is never null
				}));

			// Only create review if we have valid comments
			if (reviewComments.length > 0) {
				try {
					// Create the review with line-specific comments
					await this.octokit.rest.pulls.createReview({
						owner,
						repo,
						pull_number: prNumber,
						commit_id: headSha,
						body: "# AI 코드 리뷰 - 라인별 코멘트",
						event: "COMMENT",
						comments: reviewComments,
					});

					core.info(
						"Successfully posted code review with line-specific comments",
					);
				} catch (reviewError) {
					core.error(
						`Error creating review with comments: ${reviewError instanceof Error ? reviewError.message : String(reviewError)}`,
					);

					// Fallback to individual comments
					core.info("Falling back to individual comments");
					for (const comment of reviewComments) {
						try {
							await this.octokit.rest.pulls.createReviewComment({
								owner,
								repo,
								pull_number: prNumber,
								commit_id: headSha,
								path: comment.path,
								body: comment.body,
								line: comment.line,
							});
						} catch (commentError) {
							core.error(
								`Error posting comment on ${comment.path}:${comment.line}: ${commentError instanceof Error ? commentError.message : String(commentError)}`,
							);
						}
					}
				}
			} else {
				core.info(
					"No valid line-specific comments to post, skipping review creation",
				);
			}
		} catch (error) {
			if (error instanceof Error) {
				core.error(`Error posting review: ${error.message}`);

				// Only fall back to a regular comment if we have real content to show
				// and it's not an error message from Claude
				try {
					core.info("Falling back to posting a regular comment");
					await this.createReviewComment(
						prNumber,
						`${summary}\n\n## 상세 코멘트\n\n${comments.map((c) => `- **${c.path}:${c.line}**: ${c.body}`).join("\n\n")}`,
					);
				} catch (fallbackError) {
					core.error("Fallback comment also failed");
				}
			} else {
				core.error("Unknown error posting review");
			}
		}
	}

	async prepareReviewContext(maxFiles: number): Promise<ReviewContext> {
		const pr = await this.getPullRequestDetails();
		let files = await this.getChangedFiles(pr.number);

		// Limit number of files to analyze
		if (files.length > maxFiles) {
			core.warning(
				`Limiting analysis to ${maxFiles} files out of ${files.length} changed files`,
			);
			files = files.slice(0, maxFiles);
		}

		// Fetch full content for each file
		for (const file of files) {
			if (file.status !== "removed") {
				file.fullContent = await this.getFileContent(
					file.filename,
					pr.head.sha,
				);
			}

			if (file.status === "modified" || file.status === "renamed") {
				file.previousContent = await this.getFileContent(
					file.filename,
					pr.base.ref,
				);
			}
		}

		// Prepare review context
		const context: ReviewContext = {
			pullRequestNumber: pr.number,
			pullRequestTitle: pr.title,
			pullRequestBody: pr.body,
			repositoryName: this.context.repo.repo,
			repositoryOwner: this.context.repo.owner,
			branch: pr.head.ref,
			baseRef: pr.base.ref,
			files,
			relatedFiles: {},
		};

		return context;
	}
}
</file>

<file path="src/index.ts">
import * as core from "@actions/core";
import { ClaudeService } from "./services/claude";
import { GitHubService } from "./services/github";
import { FileAnalyzerService } from "./services/file-analyzer";
import type { ProjectType, ReviewOptions } from "./types";

async function run(): Promise<void> {
	try {
		// Get inputs from GitHub Action
		const githubToken = core.getInput("github-token", { required: true });
		const claudeApiKey = core.getInput("claude-api-key", { required: true });
		const projectType = core.getInput("project-type") as ProjectType;
		const fileExtensions = core.getInput("file-extensions").split(",");
		const excludePatterns = core.getInput("exclude-patterns").split(",");
		const findRelatedFiles = core.getInput("find-related-files") === "true";
		const maxFiles = Number.parseInt(core.getInput("max-files"), 10);
		const model = core.getInput("model");
		const useRepomix = core.getInput("use-repomix") === "true";

		// Initialize options
		const options: ReviewOptions = {
			projectType,
			fileExtensions,
			excludePatterns,
			findRelatedFiles,
			maxFiles,
			model,
			useRepomix,
		};

		// Initialize services
		const fileAnalyzerService = new FileAnalyzerService(githubToken, options);
		const githubService = new GitHubService(githubToken, fileAnalyzerService);
		const claudeService = new ClaudeService(claudeApiKey, options);

		// Prepare review context
		const context = await githubService.prepareReviewContext(maxFiles);

		// Auto-detect project type if set to 'auto'
		if (options.projectType === "auto") {
			options.projectType = fileAnalyzerService.detectProjectType(
				context.files,
			);
			core.info(`Auto-detected project type: ${options.projectType}`);
		}

		// Find related files if enabled
		if (options.findRelatedFiles) {
			context.relatedFiles =
				await fileAnalyzerService.findRelatedFiles(context);
		}

		// Generate code review
		const review = await claudeService.generateReview(context);

		// Post review as a comment on the PR with line-specific comments
		await githubService.createReviewWithComments(
			context.pullRequestNumber,
			review,
		);

		core.info("Code review completed successfully");
	} catch (error) {
		if (error instanceof Error) {
			core.setFailed(`Action failed with error: ${error.message}`);
		} else {
			core.setFailed("Action failed with an unknown error");
		}
	}
}

run();
</file>

<file path="src/types.ts">
export type ProjectType =
	| "unity"
	| "springboot"
	| "android"
	| "nextjs"
	| "auto";

export interface FileChange {
	filename: string;
	status: "added" | "modified" | "removed" | "renamed";
	patch?: string;
	fullContent?: string;
	previousContent?: string;
}

export interface RelatedFiles {
	[changedFile: string]: string[];
}

export interface ReviewOptions {
	projectType: ProjectType;
	fileExtensions: string[];
	excludePatterns: string[];
	findRelatedFiles: boolean;
	maxFiles: number;
	model: string;
	useRepomix: boolean;
}

export interface ReviewContext {
	pullRequestNumber: number;
	pullRequestTitle: string;
	pullRequestBody: string | null;
	repositoryName: string;
	repositoryOwner: string;
	branch: string;
	baseRef: string;
	files: FileChange[];
	relatedFiles: RelatedFiles;
}

export interface PromptTemplate {
	generatePrompt: (context: ReviewContext) => string;
}

export interface ReviewComment {
	path: string;
	line: number;
	body: string;
}

export interface StructuredReview {
	summary: string;
	comments: ReviewComment[];
}
</file>

<file path="package.json">
{
  "name": "code-review-assistant",
  "homepage": "https://github.com/AlohaFactory-Dev/code-review-assistant",
  "version": "1.0.0",
  "description": "GitHub Action for automated code reviews using Claude AI",
  "main": "dist/index.js",
  "scripts": {
    "build": "ncc build src/index.ts -o dist --license licenses.txt",
    "test": "jest",
    "lint": "eslint src/**/*.ts",
    "format": "prettier --write src/**/*.ts"
  },
  "keywords": [
    "github",
    "action",
    "code-review",
    "claude",
    "ai"
  ],
  "author": "Aloha Factory",
  "maintainers": [
    {
      "name": "Henry",
      "email": "henry@aloha-corp.com"
    }
  ],
  "license": "MIT",
  "dependencies": {
    "@actions/core": "^1.10.1",
    "@actions/github": "^6.0.0",
    "@anthropic-ai/sdk": "^0.17.1",
    "ignore": "^5.3.0",
    "repomix": "^0.3.1"
  },
  "devDependencies": {
    "@types/jest": "^29.5.12",
    "@types/node": "^20.11.30",
    "@typescript-eslint/eslint-plugin": "^7.3.1",
    "@typescript-eslint/parser": "^7.3.1",
    "@vercel/ncc": "^0.38.1",
    "eslint": "^9.23.0",
    "jest": "^29.7.0",
    "prettier": "^3.2.5",
    "ts-jest": "^29.1.2",
    "typescript": "^5.8.2"
  }
}
</file>

<file path="src/services/claude.ts">
import { Anthropic } from "@anthropic-ai/sdk";
import * as core from "@actions/core";
import type { ReviewContext, ReviewOptions, StructuredReview } from "../types";
import { getPromptTemplate } from "../templates/base";
import { RepomixService } from "./repomix";

export class ClaudeService {
	private client: Anthropic;
	private options: ReviewOptions;
	private repomixService: RepomixService;

	constructor(apiKey: string, options: ReviewOptions) {
		this.client = new Anthropic({ apiKey });
		this.options = options;
		this.repomixService = new RepomixService();
	}

	async generateReview(context: ReviewContext): Promise<StructuredReview> {
		try {
			core.info("Generating code review with Claude AI...");

			// Get the prompt template based on project type
			const promptTemplate = getPromptTemplate(this.options.projectType);
			let systemPrompt = promptTemplate.generatePrompt(context);

			// If the use of Repomix is enabled, pack the repository
			if (this.options.useRepomix) {
				core.info(
					"Using Repomix to pack repository for more comprehensive code review",
				);

				// Create instruction file for Repomix
				const instructionFile =
					this.repomixService.createInstructionFile(context);

				// Pack the repository
				const packedRepo = await this.repomixService.packRepository(context);

				// Add packed repo to the system prompt
				if (packedRepo && !packedRepo.startsWith("Failed")) {
					core.info("Adding packed repository to the prompt");
					systemPrompt = `${systemPrompt}\n\n# Full Repository Context\n\n${packedRepo}`;
				} else {
					core.warning(
						"Failed to pack repository with Repomix, falling back to basic review",
					);
				}
			}

			systemPrompt += `\n\n# Response Format
Please provide your review in a structured JSON format that includes:
1. A summary section with overall feedback
2. Line-specific comments for each file

Your ENTIRE response must be valid JSON enclosed in a markdown code block. Do not include any text, explanations, or comments outside the JSON code block.

Format both the "summary" and comment "body" fields as markdown text. This allows you to include:
- Code blocks with syntax highlighting
- Bullet points and numbered lists
- Bold/italic text for emphasis
- Links to documentation when relevant

The newlines in markdown should be properly escaped in the JSON as "\\n".

Example format:
\`\`\`json
{
  "summary": "## Overall Review\\n\\nThis is a markdown formatted summary with **bold text** and a list:\\n- Item 1\\n- Item 2",
  "comments": [
    {
      "path": "src/example.ts",
      "line": 42,
      "body": "Consider using a more descriptive name. Example:\\n\\n\`\`\`typescript\\nconst userId = data.id;\\n\`\`\`"
    }
  ]
}
\`\`\`

IMPORTANT: Ensure that the JSON is valid and properly escaped, especially for quotes, control characters, and special characters in strings. All markdown must be properly escaped within the JSON strings.
`;

			core.debug(`Using model: ${this.options.model}`);
			core.debug(`System prompt length: ${systemPrompt.length} characters`);

			const message = await this.client.messages.create({
				model: this.options.model,
				max_tokens: 4000,
				system: systemPrompt,
				messages: [
					{
						role: "user",
						content:
							"제공된 모든 변경사항을 검토하고 포괄적이면서도 간결한 코드 리뷰를 제공해주세요. 중요한 이슈에 집중하고, 구체적인 개선 제안을 코드 예시와 함께 제공해주세요. 변경된 파일과 관련 파일들 간의 잠재적 영향도 분석해주세요. JSON 형식으로 응답해주세요.",
					},
				],
			});

			const responseText = message.content[0].text;

			// Extract JSON from the response
			const jsonMatch =
				responseText.match(/```json\n([\s\S]*?)\n```/) ||
				responseText.match(/```\n([\s\S]*?)\n```/) ||
				responseText.match(/{[\s\S]*}/);

			if (!jsonMatch) {
				throw new Error(
					"Could not parse JSON review structure from Claude's response",
				);
			}

			const jsonString = jsonMatch[0].replace(/```json\n|```\n|```/g, "");

			// Sanitize JSON string by manually removing control characters
			let sanitizedJson = "";
			for (let i = 0; i < jsonString.length; i++) {
				const charCode = jsonString.charCodeAt(i);
				// Skip control characters
				if (
					(charCode >= 0x20 && charCode !== 0x7f) ||
					charCode === 0x09 ||
					charCode === 0x0a ||
					charCode === 0x0d
				) {
					sanitizedJson += jsonString[i];
				}
			}

			try {
				const review = JSON.parse(sanitizedJson);

				// Ensure the review has the expected structure
				if (!review.summary || !Array.isArray(review.comments)) {
					throw new Error("Invalid review structure received from Claude");
				}

				return review as StructuredReview;
			} catch (jsonError) {
				core.error(
					`JSON parsing error: ${jsonError instanceof Error ? jsonError.message : String(jsonError)}`,
				);
				core.debug(
					`Failed to parse JSON: ${sanitizedJson.substring(0, 500)}...`,
				);

				// Fallback to a simpler structure
				return {
					summary:
						"코드 리뷰 응답 파싱에 실패했습니다. JSON 형식이 올바르지 않습니다.",
					comments: [],
				};
			}
		} catch (error) {
			if (error instanceof Error) {
				core.error(`Claude API 호출 중 오류 발생: ${error.message}`);
				return {
					summary: `Claude 코드 리뷰 생성 중 오류가 발생했습니다: ${error.message}`,
					comments: [],
				};
			}
			core.error("Claude API 호출 중 알 수 없는 오류가 발생했습니다");
			return {
				summary: "알 수 없는 오류로 코드 리뷰를 생성할 수 없습니다",
				comments: [],
			};
		}
	}
}
</file>

<file path=".github/workflows/code-review-assistant.yml">
name: Code Review Assistant

on:
  pull_request:
    types: [opened, synchronize]
    # 특정 브랜치만 대상으로 하고 싶다면 아래 주석을 해제하세요
    # branches:
    #   - main
    #   - develop

permissions:
  contents: read
  pull-requests: write

jobs:
  code-review:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # Claude AI 코드 리뷰 액션 실행
      - name: Run Code Review Assistant
        uses: AlohaFactory-Dev/code-review-assistant@c1ac4192016810d5f324fe276b4652aab0aafd58
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          claude-api-key: ${{ secrets.CLAUDE_API_KEY }}

          # 프로젝트 유형 설정 (auto, unity, springboot, android, nextjs)
          # auto: 파일 패턴 기반으로 자동 감지
          project-type: 'auto'

          # 분석할 파일 확장자 (필요에 따라 수정)
          file-extensions: '.ts,.js,.tsx,.jsx,.cs,.java,.kt,.xml,.json,.yaml,.yml'

          # 제외할 파일 패턴
          exclude-patterns: 'node_modules/**,dist/**,build/**,*.min.js,*.test.*'

          # 관련 파일 분석 여부
          find-related-files: 'true'

          # 한 번에 분석할 최대 파일 수
          max-files: '10'

          # 사용할 Claude 모델
          model: 'claude-3-5-haiku-20241022'
</file>

</files>
